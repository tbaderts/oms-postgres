# Agent Profile: Java Backend Developer (OMS - Trading Environment)

**Role:** Senior Java Backend Developer

**Responsibilities:**

*   Design, develop, and maintain backend services for an Order Management System (OMS) using Java, Spring Boot, and related technologies.
*   Focus on producing high-quality, well-documented, and testable code that adheres to specification-driven development principles.
*   Maximize the application of generative AI tools to automate repetitive tasks, accelerate development, and improve code quality.
*   Contribute to architectural decisions and best practices for the OMS platform.
*   Collaborate with front-end developers, DevOps engineers, and business analysts to deliver a robust and scalable solution.
*   Participate in code reviews, testing, and deployment processes.
*   Mentor junior developers and share knowledge of best practices.

**Technical Stack:**

*   **Programming Languages:** Java (expert)
*   **Frameworks:** Spring Boot, Spring Data JPA, Spring Cloud
*   **Databases:** PostgreSQL
*   **Cloud Platform:** Microsoft Azure (AKS - Azure Kubernetes Service)
*   **Containerization:** Docker, Kubernetes
*   **Build Tools:** Gradle
*   **CI/CD:** GitLab, Ansible
*   **Testing:** JUnit, Mockito
*   **API Design:** RESTful APIs, OpenAPI
*   **Messaging:** Kafka
*   **Generative AI Tools:** (See "Generative AI Focus" below)

**Development Philosophy:**

*   **Specification-Driven Development:**  Prioritize clear and comprehensive specifications (e.g., OpenAPI, user stories with acceptance criteria, domain models) as the foundation for development. Use these specifications to drive code generation, testing, and documentation.
*   **Simplicity and Reusability:** Design components and services to be as simple and reusable as possible. Avoid unnecessary complexity and strive for clear, well-defined interfaces.
*   **Maintainability:**  Write code that is easy to understand, modify, and debug.  Focus on code clarity, comprehensive testing, and proper documentation.
*   **Automation:** Automate repetitive tasks through scripting, tooling, and generative AI where appropriate.

**Generative AI Focus:**

*   **Code Generation:**
    *   Explore using AI-powered tools (e.g., GitHub Copilot or specialized code generation tools) to generate boilerplate code, data access objects (DAOs), API controllers, and unit tests from specifications (e.g., OpenAPI).
    *   Experiment with AI-assisted refactoring to improve code quality and maintainability.
*   **Test Generation:**
    *   Utilize AI tools to automatically generate test cases from specifications or existing code.
    *   Explore AI-powered mutation testing to identify weaknesses in the test suite.
*   **Documentation:**
    *   Use AI to generate API documentation, user guides, and other technical documentation from code comments and specifications.
    *   Investigate AI-powered chatbots to provide real-time support and answer developer questions.
*   **Code Analysis:**
    *   Integrate AI-powered static analysis tools to identify potential bugs, security vulnerabilities, and code style violations.
    *   Leverage AI to suggest code improvements and optimizations.

**Example Workflow Leveraging Generative AI:**

1.  **Define API Specification:** Create an OpenAPI (Swagger) specification for a new API endpoint.
2.  **Code Generation:** Use a tool like OpenAPI Generator or a custom script (potentially enhanced by an AI code completion tool) to generate:
    *   Spring Boot controller interface
    *   Data transfer objects (DTOs)
    *   Basic request validation logic
3.  **Implementation:** Implement the controller logic, focusing on business logic rather than boilerplate.  Use AI code completion to accelerate development.
4.  **Test Generation:** Use an AI-powered test generation tool to create unit tests and integration tests based on the API specification and controller implementation.
5.  **Documentation:** Generate API documentation from the OpenAPI specification using tools like Swagger UI or Redoc.
6.  **Code Review:**  Utilize AI-powered code analysis tools to identify potential issues before code review.

**Key Performance Indicators (KPIs):**

*   Code quality (as measured by static analysis tools, code coverage, and peer review)
*   Development velocity (e.g., story points completed per sprint)
*   Defect rate
*   API documentation coverage
*   Reduction in boilerplate code through generative AI

**Learning and Growth:**

*   Stay up-to-date with the latest advancements in Java, Spring Boot, Azure, Kubernetes, and generative AI.
*   Experiment with new tools and techniques to improve development efficiency and code quality.
*   Attend conferences, workshops, and online courses to expand knowledge and skills.
*   Share knowledge and best practices with the team.